<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: support/collapse.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: support/collapse.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var array_map = require("./array-map");
var is_array = Array.isArray;
var is_primitive = require("./is-primitive");

module.exports = function collapse(pathmap) {
    return array_map(buildQueries(pathmap), collapseRangeIndexes);
};

// Note: export this for testing
module.exports.buildQueries = buildQueries;

/**
 * Collapse range indexers, e.g. when there is a continuous
 * range in an array, turn it into an object instead:
 *
 * [1,2,3,4,5,6] => {"from":1, "to":6}
 *
 */
function collapseRangeIndexes(pathset) {
    
    var keysetIndex = -1;
    var keysetCount = pathset.length;

    while (++keysetIndex &lt; keysetCount) {

        var keyset = pathset[keysetIndex];

        if (is_array(keyset)) {

            // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?
            // var hash = {};
            var isSparseRange = true;
            var keyIndex = -1;
            var keyCount = keyset.length - 1;

            while (++keyIndex &lt;= keyCount) {

                var key = keyset[keyIndex];

                if (!isNumber(key) /* || hash[key] === true*/ ) {
                    isSparseRange = false;
                    break;
                }
                // hash[key] = true;
                // Cast number indexes to integers.
                keyset[keyIndex] = parseInt(key, 10);
            }

            if (isSparseRange === true) {
                
                keyset.sort(sortListAscending);
                
                var from = keyset[0];
                var to = keyset[keyCount];
                
                // If we re-introduce deduped integer indexers, change this comparson to "===".
                if (to - from &lt;= keyCount) {
                    pathset[keysetIndex] = {
                        from: from,
                        to: to
                    };
                }
            }
        }
    }
    
    return pathset;
}

function sortListAscending(a, b) {
    return a - b;
}

/**
 * Builds the set of collapsed
 * queries by traversing the tree
 * once
 */

/* jshint forin: false */
function buildQueries(pathmap) {

    if (is_primitive(pathmap)) {
        return [[]];
    }

    var keys = Object.keys(pathmap);
    var keysIndex = -1;
    var keysCount = keys.length;
    
    if (keysCount === 0) {
        return [[]];
    }

    var subPaths = {};
    var subPath, subPathKeys, subPathSets, clone, j, k, x;

    while (++keysIndex &lt; keysCount) {
        
        var key = keys[keysIndex];
        var pathsets = buildQueries(pathmap[key]);
        var pathsetsKey = createKey(pathsets);
        
        subPath = subPaths[pathsetsKey] || (subPaths[pathsetsKey] = {
            head: [],
            tail: pathsets
        });
        subPathKeys = subPath.head;
        subPathKeys[subPathKeys.length] = isNumber(key) ? parseInt(key, 10) : key;
    }

    var results = [];
    var resultsLength = 0;

    for(pathsetsKey in subPaths) {
        
        subPath = subPaths[pathsetsKey];
        subPathKeys = subPath.head;
        subPathSets = subPath.tail;
        
        var firstSubPathsKey = subPathKeys[0];
        var subPathKeysCount = subPathKeys.length;
        
        var subPathSetsIndex = -1;
        var subPathSetsCount = subPathSets.length;
        
        while(++subPathSetsIndex &lt; subPathSetsCount) {
            
            var pathset = subPathSets[subPathSetsIndex];
            var pathsetClone = [];
            
            if(firstSubPathsKey !== "") {
                
                pathsetClone[0] = subPathKeysCount === 1 ? firstSubPathsKey : subPathKeys;
                
                var pathsetIndex = -1;
                var pathsetCount = pathset.length;
                
                while(++pathsetIndex &lt; pathsetCount) {
                    pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];
                }
            }
            
            results[resultsLength++] = pathsetClone;
        }
    }
    
    return results;
}

/**
 * Return true if argument is a number or can be cast to a number
 */
function isNumber(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !is_array(val) &amp;&amp; (val - parseFloat(val) + 1) >= 0;
}

/**
 * allUnique
 * return true if every number in an array is unique
 */
function allUnique(arr) {
    var hash = {},
        index, count;
    for (index = 0, count = arr.length; index &lt; count; index++) {
        if (hash[arr[index]]) {
            return false;
        }
        hash[arr[index]] = true;
    }
    return true;
}

/**
 * Create a unique hash key for a set of paths
 */
function createKey(list) {
    return JSON.stringify(sortListOfLists(list));
}

/**
 * Sort a list-of-lists
 * Used for generating a unique hash key for each subtree; used by the memoization
 */
function sortListOfLists(list) {
    var index = 0;
    var result = [];
    var listIndex = -1;
    var listCount = list.length;
    while(++listIndex &lt; listCount) {
        var value = list[listIndex];
        result[index++] = is_array(value) ?
            sortListOfLists(value) :
            value;
    }
    return result.sort();
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HttpDataSource.html">HttpDataSource</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelResponse.html">ModelResponse</a></li><li><a href="Observable.html">Observable</a></li><li><a href="Subscription.html">Subscription</a></li></ul><h3>Interfaces</h3><ul><li><a href="DataSource.html">DataSource</a></li></ul><h3>Global</h3><ul><li><a href="global.html#allUnique">allUnique</a></li><li><a href="global.html#buildQueries">buildQueries</a></li><li><a href="global.html#collapseRangeIndexes">collapseRangeIndexes</a></li><li><a href="global.html#createKey">createKey</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#getSourceObserver">getSourceObserver</a></li><li><a href="global.html#InvalidModelError">InvalidModelError</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#performGetOnModelSource">performGetOnModelSource</a></li><li><a href="global.html#set_json_values_as_json_values">set_json_values_as_json_values</a></li><li><a href="global.html#sortListOfLists">sortListOfLists</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.1</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
