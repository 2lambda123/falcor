<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Class: ModelResponse</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Class: ModelResponse</h1>

    




<section>

<header>
    
        <h2>
        ModelResponse
        </h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        

    

    <h4 class="name" id="ModelResponse"><span class="type-signature"></span>new ModelResponse<span class="signature">()</span><span class="type-signature"></span></h4>

    



<div class="description">
    A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. A ModelResponse can convert the data in the container into any of the following formats: JSON, <a href="global.html#JSONGraph">JSONGraph</a>, a stream of <a href="global.html#PathValue">PathValue</a>s, or a scalar value. Once the data format is determined, the ModelResponse container can be converted into any of the following container types: Observable (default), or a Promise. A ModelResponse can also push data to a node-style callback.
</div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line1024">line 1024</a>
    </li></ul></dd>
    

    

    

    
</dl>















    <h5>Example</h5>
    
    <pre class="prettyprint"><code>var model = new falcor.Model();
var $ref = falcor.Model.ref;

// Loading a JSONGraph object into the model's cache.
model.setCache(
    {
        // list of user's genres, modeled as a map with ordinal keys
        "genreLists": {
            "0": $ref('genresById[123]'),
            "1": $ref('genresById[522]'),
            "length": 2
        },
        // map of all genres, organized by ID
        "genresById": {
            // genre list modeled as map with ordinal keys
            "123": {
                "name": "Drama",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[99]'),
                "length": 2
            },
            // genre list modeled as map with ordinal keys
            "522": {
                "name": "Comedy",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[44]'),
                "length": 2           
            }
        },
        // map of all titles, organized by ID
        "titlesById": {
           "99": {
                "name": "House of Cards",
                "rating": 5
            },
            "23": {
                "name": "Orange is the New Black",
                "rating": 5
            },
            "44": {
                "name": "Arrested Development",
                "rating": 5            
            }
        }
    });

// Use a path set containing ranges and arrays to retrieve the name and rating of the first two titles in the first two genre lists.
var modelResponse = 
    model.
        get('genreLists[0..1][0...2]["name", "rating"]');

// The path evaluator expands the path set above to a set of 8 <a href="global.html#Path">Path</a> objects.
// In other words the code below produces the same dataset as the code above:

modelResponse.toPathValues().forEach(function(json) { 
    console.log(JSON.stringify(json));
});

// the code above should print the output below:
// {"path":["genreLists",0,0,"name"],"value":"Orange is the New Black"}
// {"path":["genreLists",0,0,"rating"],"value":5}
// {"path":["genreLists",0,1,"name"],"value":"House of Cards"}
// {"path":["genreLists",0,1,"rating"],"value":5}
// {"path":["genreLists",1,0,"name"],"value":"Orange is the New Black"}
// {"path":["genreLists",1,0,"rating"],"value":5}
// {"path":["genreLists",1,1,"name"],"value":"Arrested Development"}
// {"path":["genreLists",1,1,"rating"],"value":5}


modelResponse.toJSON().forEach(function(json) { 
    console.log(JSON.stringify(json, null, 4));
});

// the code above should print the output below:
// {
//     "json": {
//         "genreLists": {
//             "0": {
//                 "0": {
//                     "name": "Orange is the New Black",
//                     "rating": 5
//                 },
//                 "1": {
//                     "name": "House of Cards",
//                     "rating": 5
//                 }
//             },
//             "1": {
//                 "0": {
//                     "name": "Orange is the New Black",
//                     "rating": 5
//                 },
//                 "1": {
//                     "name": "Arrested Development",
//                     "rating": 5
//                 }
//             }
//         }
//     }
// }</code></pre>



    
    </div>

    
        <h3 class="subsection-title">Extends</h3>

        


    <ul>
        <li><a href="Observable.html">Observable</a></li>
    </ul>


    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id="forEach"><span class="type-signature"></span>forEach<span class="signature">(onNext<span class="signature-attributes">nullable</span>, onError<span class="signature-attributes">nullable</span>, onCompleted<span class="signature-attributes">nullable</span>)</span><span class="type-signature"> &rarr; {<a href="Subscription.html">Subscription</a>}</span></h4>

    



<div class="description">
    The forEach method triggers the execution of the Observable, causing the values within to be pushed to a callback. An Observable is like a pipe of water that is closed. When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an Observer object.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>onNext</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Observable.html#~onNextCallback">Observable~onNextCallback</a></span>


            
            </td>

            
                <td class="attributes">
                

                
                    &lt;nullable><br>
                

                
                </td>
            

            

            <td class="description last">a callback that accepts the next value in the stream of values.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>onError</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Observable.html#~onErrorCallback">Observable~onErrorCallback</a></span>


            
            </td>

            
                <td class="attributes">
                

                
                    &lt;nullable><br>
                

                
                </td>
            

            

            <td class="description last">a callback that accepts an error that occurred while evaluating the operation underlying the <a href="Observable.html">Observable</a> stream.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>onCompleted</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Observable.html#~onCompletedCallback">Observable~onCompletedCallback</a></span>


            
            </td>

            
                <td class="attributes">
                

                
                    &lt;nullable><br>
                

                
                </td>
            

            

            <td class="description last">a callback that is invoked the <a href="Observable.html">Observable</a> stream has ended, and the <a href="Observable.html#~onNextCallback">Observable~onNextCallback</a> will not receive any more values.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    
    <dt class="inherited-from">Inherited From:</dt>
    <dd class="inherited-from"><ul class="dummy"><li>
        <a href="Observable.html#forEach">Observable#forEach</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line3041">line 3041</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        


<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="Subscription.html">Subscription</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="progressively"><span class="type-signature"></span>progressively<span class="signature">(&hellip;path, selector)</span><span class="type-signature"> &rarr; {<a href="ModelResponse.html">ModelResponse</a>.&lt;<a href="global.html#JSONEnvelope">JSONEnvelope</a>>}</span></h4>

    



<div class="description">
    The progressive method retrieves several <a href="global.html#Path">Path</a>s or <a href="global.html#PathSet">PathSet</a>s from the JSONGraph object, and makes them
available in the local cache. Like the Model.prototype.getProgressively function, getProgressively invokes a 
selector function every time is available, creating a stream of objects where each new object is a more populated version 
of the one before. The getProgressively function is a memory-efficient alternative to the getProgressively function, because get does not convert the requested data from JSONGraph to JSON. Instead the getProgressively function attempts to ensure that the requested paths are locally available in the cache when it invokes a selector function. Within the selector function, data is synchronously retrieved from the local cache and translated into another form - usually a view object. Within the selector function you can use helper methods like getValueSync and setValueSync to synchronously retrieve data from the cache. These methods are only valid within the selector function, and will throw if executed anywhere else.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>path</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="global.html#PathSet">PathSet</a></span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last">the path(s) to retrieve</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>selector</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">the callback that runs once all of the values have been loaded into cache</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line1863">line 1863</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    the values found at the requested paths.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="ModelResponse.html">ModelResponse</a>.&lt;<a href="global.html#JSONEnvelope">JSONEnvelope</a>></span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// In this example we will retrieve data from the model and convert it into an HTML representation.
// Creating a model and passing a data source that connects it to a remote JSONGraph model.
var model = new falcor.Model();
var $ref = falcor.Model.ref;

// Loading a JSONGraph object into the model's cache. This JSONGraph object models a list of genres, each of which contains several titles.
model.setCache(
    {
        // list of user's genres, modeled as a map with ordinal keys
        "genreLists": {
            "0": $ref('genresById[123]'),
            "1": $ref('genresById[522]'),
            "length": 2
        },
        // map of all genres, organized by ID
        "genresById": {
            // genre list modeled as map with ordinal keys
            "123": {
                "name": "Drama",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[99]'),
                "length": 2
            },
            // genre list modeled as map with ordinal keys
            "522": {
                "name": "Comedy",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[44]'),
                "length": 2           
            }
        },
        // map of all titles by ID
        "titlesById": {
           "99": {
                "name": "House of Cards",
                "rating": 5
            },
            "23": {
                "name": "Orange is the New Black",
                "rating": 5
            },
            "44": {
                "name": "Arrested Development",
                "rating": 5            
            }
        }
    });

// Converts a integer into a string of stars
function getStars(num) {
    var stars = "",
        counter;

    if (num !== undefined) {
        for(counter = 0; counter &lt; num; counter++) {
            stars += "*";
        }
    }

    return stars;
}

// Note that in the example below we ask for the first three titles in the first genre list. This will 
// result in a request to the server for ["genreLists", 0, 2, ["name","rating"]] because the third title 
// is not in the cache. The selector function passed to getProgressively will be called twice. The first time, the only data available in the cache will be the data that was already present. The second time the cache will also contain the additional data downloaded from the server.
// Each time the selector function is invoked, there is more data. The selector function converts the 
// data present into an HTML representation. The result is a stream of progressively larger HTML strings.
var nameAndRatings = model.progressive().get(
    'genreLists[0][0..2]["name", "rating"]', 'genreLists[0].name',
    // When this function is invoked all of the data should be available in the cache, except for those paths that caused an error to occur
    function() {
        var firstGenreList = model.bindSync('genreLists[0]');
        return "&lt;h1>" + firstGenreList.getValueSync('name') + "&lt;/h1>\n" +
            "&lt;ul>\n" + 
            [0,1,2].
                // filter out indexes that have not been retrieved from the server yet
                filter(function(index) {
                    // when retrieving values from the local cache, it is possible to retrieve objects as well as values.
                    return firstGenreList.getValueSync([index]) !== undefined;
                }).
                map(function(index) {
                    var nameAndRating = firstGenreList.bindSync([index]);
                    return "&lt;li>" + nameAndRating.getValueSync('name') + " " + getStars(nameAndRating.getValueSync('rating')) + "&lt;/li>\n";
                }).join("") + 
            "&lt;/ul>";
    });

nameAndRatings.forEach(function(html) { 
    console.log(html); 
});

// The code above outputs the following two HTML fragments to the console.
// &lt;h1>Drama&lt;/h1>
// &lt;ul>
// &lt;li>Orange is the New Black *****&lt;/li>
// &lt;li>House of cards *****&lt;/li>
// &lt;/ul>
// &lt;h1>Drama&lt;/h1>
// &lt;ul>
// &lt;li>Orange is the New Black *****&lt;/li>
// &lt;li>House of Cards *****&lt;/li>
// &lt;li>Hemlock Grove *****&lt;/li>
// &lt;/ul>
// Notice that the first HTML Fragment does not contain the "Hemlock Grove" title. However the second time around the title has been downloaded from the remote model and is present in the results.</code></pre>



        
            

    

    <h4 class="name" id="toJSON"><span class="type-signature"></span>toJSON<span class="signature">()</span><span class="type-signature"></span></h4>

    



<div class="description">
    Converts the data format of the results to JSON.
</div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line1287">line 1287</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    ModelResponse.<JSONEnvelope>
</div>



    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>var model = new falcor.Model();
var $ref = falcor.Model.ref;

// Loading a JSONGraph object into the model's cache.
model.setCache(
    {
        // list of user's genres, modeled as a map with ordinal keys
        "genreLists": {
            "0": $ref('genresById[123]'),
            "1": $ref('genresById[522]'),
            "length": 2
        },
        // map of all genres, organized by ID
        "genresById": {
            // genre list modeled as map with ordinal keys
            "123": {
                "name": "Drama",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[99]'),
                "length": 2
            },
            // genre list modeled as map with ordinal keys
            "522": {
                "name": "Comedy",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[44]'),
                "length": 2           
            }
        },
        // map of all titles by ID
        "titlesById": {
           "99": {
                "name": "House of Cards",
                "rating": 5
            },
            "23": {
                "name": "Orange is the New Black",
                "rating": 5
            },
            "44": {
                "name": "Arrested Development",
                "rating": 5            
            }
        }
    });

// get the ModelResponse
var response = model.get('genreLists[0][0]["name", "rating"]');

response.toJSON().forEach(function(jsonEnvelope) { 
    console.log(JSON.stringify(jsonEnvelope, null, 4)); 
});

// The code above outputs the following <a href="global.html#JSONEnvelope">JSONEnvelope</a> to the console.
// {
//     "json": {
//         // list of user's genres, modeled as a map with ordinal keys
//         "genreLists": {
//             "0": {
//                 "0": {
//                     "name": "Orange is the New Black",
//                     "rating": 5
//                 }
//             }
//         }    
//     }
// }</code></pre>



        
            

    

    <h4 class="name" id="toJSONG"><span class="type-signature"></span>toJSONG<span class="signature">()</span><span class="type-signature"></span></h4>

    



<div class="description">
    Converts the data format of the data returned in a Model Response to JSONGraph.
</div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line1201">line 1201</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    ModelResponse.<JSONGraphEnvelope>
</div>



    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>var model = new falcor.Model();
var $ref = falcor.Model.ref;

// Loading a JSONGraph object into the model's cache.
model.setCache(
    {
        // list of user's genres, modeled as a map with ordinal keys
        "genreLists": {
            "0": $ref('genresById[123]'),
            "1": $ref('genresById[522]'),
            "length": 2
        },
        // map of all genres, organized by ID
        "genresById": {
            // genre list modeled as map with ordinal keys
            "123": {
                "name": "Drama",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[99]'),
                "length": 2
            },
            // genre list modeled as map with ordinal keys
            "522": {
                "name": "Comedy",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[44]'),
                "length": 2           
            }
        },
        // map of all titles by ID
        "titlesById": {
           "99": {
                "name": "House of Cards",
                "rating": 5
            },
            "23": {
                "name": "Orange is the New Black",
                "rating": 5
            },
            "44": {
                "name": "Arrested Development",
                "rating": 5            
            }
        }
    });

// get the ModelResponse
var response = model.get(["genreLists", 0, 0, ["name","rating"]]);

response.toJSONG().forEach(function(jsonGraphEnvelope) { 
    console.log(JSON.stringify(jsonGraphEnvelope)); 
});

// The code above outputs the following <a href="global.html#JSONGraphEnvelope">JSONGraphEnvelope</a> to the console.
// {
//     "paths": [["genreLists", 0, 0, ["name","rating"]]],
//     "jsong": {
//         // list of user's genres, modeled as a map with ordinal keys
//         "genreLists": {
//             "0": { $type: "ref", value: ["genresById", 123] }
//         },
//         // map of all genres, organized by ID
//         "genresById": {
//             // genre list modeled as map with ordinal keys
//             "123": {
//                 "0": { $type: "ref", value: ["titlesById", 23] }
//             }
//         },
//         // map of all titles by ID
//         "titlesById": {
//             "23": {
//                 "name": "Orange is the New Black",
//                 "rating": 5
//             }
//         }
//     }    
// }</code></pre>



        
            

    

    <h4 class="name" id="toPathValues"><span class="type-signature"></span>toPathValues<span class="signature">()</span><span class="type-signature"></span></h4>

    



<div class="description">
    Converts the data format of the data in a JSONGraph Model response to a stream of path values.
</div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="docs.js.html">docs.js</a>, <a href="docs.js.html#line1132">line 1132</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    ModelResponse.<PathValue>
</div>



    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>var model = new falcor.Model();
var $ref = falcor.Model.ref;

// Loading a JSONGraph object into the model's cache.
model.setCache(
    {
        // list of user's genres, modeled as a map with ordinal keys
        "genreLists": {
            "0": $ref('genresById[123]'),
            "1": $ref('genresById[522]'),
            "length": 2
        },
        // map of all genres, organized by ID
        "genresById": {
            // genre list modeled as map with ordinal keys
            "123": {
                "name": "Drama",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[99]'),
                "length": 2
            },
            // genre list modeled as map with ordinal keys
            "522": {
                "name": "Comedy",
                "0": $ref('titlesById[23]'),
                "1": $ref('titlesById[44]'),
                "length": 2           
            }
        },
        // map of all titles by ID
        "titlesById": {
           "99": {
                "name": "House of Cards",
                "rating": 5
            },
            "23": {
                "name": "Orange is the New Black",
                "rating": 5
            },
            "44": {
                "name": "Arrested Development",
                "rating": 5            
            }
        }
    });

// get the ModelResponse
var response = model.get('genreLists[0][0]["name", "rating"]');

response.toPathValues().forEach(function(pathValue) { 
    console.log(JSON.stringify(pathValue)); 
});

// The code above outputs the following <a href="global.html#PathValue">PathValue</a>s to the console in non-deterministic order.
// {"path":["genreLists",0,0,"rating"],"value":5}
// {"path":["genreLists",0,0,"name"],"value":"Orange is the New Black"}

// Note that the values above were returned out of order. This was possible 
// because each PathValue provides sufficient context (ie the path) to 
// differentiate which value is being sent.</code></pre>



        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DataSource.html">DataSource</a></li><li><a href="HttpDataSource.html">HttpDataSource</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelResponse.html">ModelResponse</a></li><li><a href="Observable.html">Observable</a></li><li><a href="Subscription.html">Subscription</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>